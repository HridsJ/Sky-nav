<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SKY-NAV</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Bebas Neue', sans-serif;
            background: linear-gradient(135deg, #000000 0%, #0d0d0d 50%, #1a1a1a 100%);
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        @font-face {
            font-family: 'Bebas Neue';
            src: url('assets/fonts/BebasNeue.woff2') format('woff2');
            font-weight: normal;
            font-style: normal;
        } 

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 2rem;
        }

        .hero {
            text-align: center;
            padding: 6rem 0 4rem;
            position: relative;
        }

        .hero::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 200px;
            background: radial-gradient(circle, rgba(59, 130, 246, 0.3) 0%, transparent 70%);
            border-radius: 50%;
            filter: blur(40px);
            animation: float 6s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateX(-50%) translateY(0px); }
            50% { transform: translateX(-50%) translateY(-20px); }
        }

        .logo {
            font-size: clamp(4rem, 8vw, 8rem);
            font-weight: 800;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6, #06b6d4);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 2rem;
            letter-spacing: -0.02em;
            position: relative;
            z-index: 1;
        }

        .subtitle {
            font-size: 1.5rem;
            color: #94a3b8;
            margin-bottom: 3rem;
            font-weight: 300;
        }

        .content-section {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 3rem;
            margin: 3rem 0;
            transition: all 0.3s ease;
        }

        .content-section:hover {
            transform: translateY(-5px);
            background: rgba(255, 255, 255, 0.08);
            box-shadow: 0 20px 40px rgba(59, 130, 246, 0.2);
        }

        .section-title {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 1.5rem;
            color: #f1f5f9;
        }

        .description-text {
            font-size: 1.125rem;
            line-height: 1.8;
            color: #cbd5e1;
            margin-bottom: 1.5rem;
        }

        .links-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            margin: 4rem 0;
        }

        .link-card {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(139, 92, 246, 0.1));
            border: 2px solid transparent;
            border-radius: 16px;
            padding: 2.5rem;
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            cursor: pointer;
        }

        .link-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }

        .link-card:hover::before {
            left: 100%;
        }

        .link-card:hover {
            transform: translateY(-8px) scale(1.02);
            border-color: rgba(59, 130, 246, 0.5);
            box-shadow: 0 25px 50px rgba(59, 130, 246, 0.3);
        }

        .link-icon {
            width: 48px;
            height: 48px;
            object-fit: contain;
            margin-bottom: 1rem;
            display: block;
            margin-left: auto;
            margin-right: auto;
        }

        .link-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #f1f5f9;
        }

        .link-description {
            color: #94a3b8;
            margin-bottom: 1.5rem;
            font-size: 1rem;
        }

        .link-button {
            display: inline-block;
            padding: 0.75rem 2rem;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            color: white;
            text-decoration: none;
            border-radius: 50px;
            font-weight: 600;
            transition: all 0.3s ease;
            position: relative;
            z-index: 1;
        }

        .link-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(59, 130, 246, 0.4);
        }

        /* Reactive background canvas */
        #reactive-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }

        /* Apple-style scroll animation section */
        .launch-section {
            height: 300vh;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .launch-container {
            position: sticky;
            top: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .launch-text {
            font-size: 3rem;
            font-weight: 700;
            text-align: center;
            margin-bottom: 3rem;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6, #06b6d4);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            opacity: 0;
            transform: translateY(30px);
            transition: all 0.8s ease;
        }

        .launch-text.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .preview-container {
            position: relative;
            width: 400px;
            height: 300px;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            transition: all 0.6s cubic-bezier(0.25, 0.1, 0.25, 1);
        }

        .preview-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 20px;
            transition: all 0.6s cubic-bezier(0.25, 0.1, 0.25, 1);
        }

        .preview-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1), rgba(139, 92, 246, 0.1));
            border: 2px solid rgba(59, 130, 246, 0.3);
            border-radius: 20px;
            opacity: 0;
            transition: all 0.6s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .preview-overlay::before {
            content: ' ';
            color: white;
            font-size: 1.5rem;
            font-weight: 600;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        .preview-container:hover .preview-overlay {
            opacity: 1;
        }

        .transition-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000000;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.8s ease;
        }

        .transition-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        .transition-preview {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            height: 300px;
            border-radius: 20px;
            overflow: hidden;
            transition: all 1.2s cubic-bezier(0.25, 0.1, 0.25, 1);
        }

        .transition-preview.expand {
            width: 100vw;
            height: 100vh;
            border-radius: 0;
        }

        .transition-preview img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        @media (max-width: 768px) {
            .content-section {
                padding: 2rem;
                margin: 2rem 0;
            }
            
            .links-section {
                grid-template-columns: 1fr;
                gap: 1.5rem;
            }
            
            .link-card {
                padding: 2rem;
            }

            .launch-text {
                font-size: 2rem;
                padding: 0 1rem;
            }

            .preview-container {
                width: 300px;
                height: 200px;
            }

            .transition-preview {
                width: 300px;
                height: 200px;
            }
        }
    </style>
</head>
<body>
    <canvas id="reactive-canvas"></canvas>
    
    <div class="container">
        <header class="hero">
            <h1 class="logo">SKY - NAV</h1>
            <p class="subtitle">Drone Navigation System</p>
        </header>

        <section class="content-section">
            <h2 class="section-title">About the tool</h2>
            <p class="description-text">
                Skynav is a web application designed to optimize flight paths for small aircraft, including drones and light 
                helicopters. Leveraging the OpenWeather API, it gathers real-time data on snow, rain, and wind. A sophisticated 
                algorithm, combining A* search with a scikit-learn forest classifier, calculates the safest, most efficient 
                routes, minimizing weather exposure. These routes are then visualized on an interactive map using Leaflet, 
                providing pilots with clear, dynamic guidance. Skynav enhances flight safety and efficiency by delivering 
                data-driven, weather-aware route planning within a user-friendly web interface. This accessibility allows for 
                pre-flight planning and in-flight adjustments from any device with internet access.
            </p>
        </section>

        <div class="links-section">
            <div class="link-card">
                <img src="assets/github.svg" class="link-icon" />
                <h3 class="link-title">Source Code</h3>
                <p class="link-description">
                    Explore the codebase, contribute to development, and see how Sky-nav is built from the ground up.
                </p>
                <a href="https://github.com/HridsJ/Sky-nav" class="link-button" target="_blank">View on GitHub</a>
            </div>

            <div class="link-card">
                <img src="assets/logo.png" class="link-icon" />
                <h3 class="link-title">Ready to Navigate?</h3>
                <p class="link-description">
                    Experience the future of drone navigation. Scroll down to launch Sky-nav in an immersive way.
                </p>
                <div class="link-button" style="cursor: default; opacity: 0.8;">Scroll to Launch</div>
            </div>
        </div>
    </div>

    <section class="launch-section">
        <div class="launch-container">
            <h2 class="launch-text" id="launchText"> </h2>
            <div class="preview-container" id="previewContainer">
                <img src="assets/preview.png" alt="SKY-NAV Preview" class="preview-image">
                <div class="preview-overlay"></div>
            </div>
        </div>
    </section>

    <div class="transition-overlay" id="transitionOverlay">
        <div class="transition-preview" id="transitionPreview">
            <img src="assets/preview.png" alt="SKY-NAV Preview">
        </div>
    </div>

    <script>
        // Reactive particle background system with lighting effect
        class ReactiveBackground {
            constructor() {
                this.canvas = document.getElementById('reactive-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.particles = [];
                this.mouse = { x: -999, y: -999 };
                this.particleCount = 150;
                this.maxDistance = 120;
                this.mouseRadius = 180;
                this.time = 0;
                
                this.init();
                this.animate();
                this.setupEventListeners();
            }

            init() {
                this.resizeCanvas();
                this.createParticles();
            }

            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            createParticles() {
                this.particles = [];
                for (let i = 0; i < this.particleCount; i++) {
                    this.particles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        baseOpacity: Math.random() * 0.015 + 0.05,
                        currentOpacity: Math.random() * 0.3 + 0.1,
                        size: Math.random() * 2 + 1,
                        baseSize: Math.random() * 2 + 1,
                        pulseSpeed: Math.random() * 0.02 + 0.01,
                        pulseOffset: Math.random() * Math.PI * 2,
                        driftX: (Math.random() - 0.5) * 0.5,
                        driftY: (Math.random() - 0.5) * 0.5,
                        originalX: 0,
                        originalY: 0
                    });
                    
                    // Store original position
                    this.particles[i].originalX = this.particles[i].x;
                    this.particles[i].originalY = this.particles[i].y;
                }
            }

            drawParticle(particle) {
                // Calculate glow intensity based on mouse proximity
                const dx = this.mouse.x - particle.x;
                const dy = this.mouse.y - particle.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                let glowIntensity = 0;
                if (distance < this.mouseRadius) {
                    glowIntensity = 1 - (distance / this.mouseRadius);
                    glowIntensity = Math.pow(glowIntensity, 2); // Smoother falloff
                }

                // Base particle with subtle pulse
                const pulse = Math.sin(this.time * particle.pulseSpeed + particle.pulseOffset) * 0.2 + 0.6;
                const opacity = particle.baseOpacity * pulse + glowIntensity * 0.8;
                const size = particle.baseSize + glowIntensity * 2;

                // Outer glow effect
                if (glowIntensity > 0) {
                    const glowSize = size * (3 + glowIntensity * 2);
                    const gradient = this.ctx.createRadialGradient(
                        particle.x, particle.y, 0,
                        particle.x, particle.y, glowSize
                    );
                    gradient.addColorStop(0, `rgba(59, 130, 246, ${glowIntensity * 0.01})`);
                    gradient.addColorStop(0.3, `rgba(139, 92, 246, ${glowIntensity * 0.005})`);
                    gradient.addColorStop(0.6, `rgba(6, 182, 212, ${glowIntensity * 0.0003})`);
                    gradient.addColorStop(1, `rgba(59, 130, 246, 0)`);
                    
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, glowSize, 0, Math.PI * 2);
                    this.ctx.fillStyle = gradient;
                    this.ctx.fill();
                }

                // Core particle
                this.ctx.beginPath();
                this.ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
                this.ctx.fillStyle = `rgba(59, 130, 246, ${Math.min(1, opacity)})`;
                this.ctx.fill();

                // Bright center for lit particles
                if (glowIntensity > 0.3) {
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, size * 0.5, 0, Math.PI * 2);
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${glowIntensity * 0.3})`;
                    this.ctx.fill();
                }
            }

            drawConnection(p1, p2, distance) {
                // Calculate lighting effect for connections
                const midX = (p1.x + p2.x) / 2;
                const midY = (p1.y + p2.y) / 2;
                const midDx = this.mouse.x - midX;
                const midDy = this.mouse.y - midY;
                const midDistance = Math.sqrt(midDx * midDx + midDy * midDy);
                
                let connectionGlow = 0;
                if (midDistance < this.mouseRadius) {
                    connectionGlow = 1 - (midDistance / this.mouseRadius);
                    connectionGlow = Math.pow(connectionGlow, 2);
                }

                const baseOpacity = Math.pow(1 - (distance / this.maxDistance), 2) * 0.01;
                const finalOpacity = baseOpacity + connectionGlow * 0.7;
                
                if (finalOpacity > 0.05) {
                    // Enhanced connection with gradient
                    const gradient = this.ctx.createLinearGradient(p1.x, p1.y, p2.x, p2.y);
                    gradient.addColorStop(0, `rgba(59, 130, 246, ${finalOpacity})`);
                    gradient.addColorStop(0.5, `rgba(139, 92, 246, ${finalOpacity * 0.8})`);
                    gradient.addColorStop(1, `rgba(59, 130, 246, ${finalOpacity})`);
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(p1.x, p1.y);
                    this.ctx.lineTo(p2.x, p2.y);
                    this.ctx.strokeStyle = gradient;
                    this.ctx.lineWidth = Math.max(0.3, finalOpacity * 0.2);
                    this.ctx.stroke();
                }
            }

            updateParticle(particle) {
                // Gentle drift animation - particles stay in place but drift slightly
                particle.x = particle.originalX + Math.sin(this.time * particle.pulseSpeed) * 20 + particle.driftX * this.time * 0.1;
                particle.y = particle.originalY + Math.cos(this.time * particle.pulseSpeed * 0.8) * 15 + particle.driftY * this.time * 0.1;

                // Wrap around screen edges
                if (particle.x < -50) {
                    particle.originalX = this.canvas.width + 50;
                    particle.x = particle.originalX;
                }
                if (particle.x > this.canvas.width + 50) {
                    particle.originalX = -50;
                    particle.x = particle.originalX;
                }
                if (particle.y < -50) {
                    particle.originalY = this.canvas.height + 50;
                    particle.y = particle.originalY;
                }
                if (particle.y > this.canvas.height + 50) {
                    particle.originalY = -50;
                    particle.y = particle.originalY;
                }
            }

            animate() {
                this.time += 0.016; // Roughly 60fps timing
                
                // Clear canvas with fade effect
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Update particles
                this.particles.forEach(particle => {
                    this.updateParticle(particle);
                });

                // Draw connections first (behind particles)
                for (let i = 0; i < this.particles.length; i++) {
                    for (let j = i + 1; j < this.particles.length; j++) {
                        const dx = this.particles[i].x - this.particles[j].x;
                        const dy = this.particles[i].y - this.particles[j].y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < this.maxDistance) {
                            this.drawConnection(this.particles[i], this.particles[j], distance);
                        }
                    }
                }

                // Draw particles on top
                this.particles.forEach(particle => {
                    this.drawParticle(particle);
                });

                requestAnimationFrame(() => this.animate());
            }

            setupEventListeners() {
                window.addEventListener('mousemove', (e) => {
                    this.mouse.x = e.clientX;
                    this.mouse.y = e.clientY;
                });

                window.addEventListener('mouseleave', () => {
                    this.mouse.x = -999;
                    this.mouse.y = -999;
                });

                window.addEventListener('resize', () => {
                    this.resizeCanvas();
                    this.createParticles();
                });

                // Touch support for mobile
                window.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (e.touches[0]) {
                        this.mouse.x = e.touches[0].clientX;
                        this.mouse.y = e.touches[0].clientY;
                    }
                }, { passive: false });

                window.addEventListener('touchstart', (e) => {
                    if (e.touches[0]) {
                        this.mouse.x = e.touches[0].clientX;
                        this.mouse.y = e.touches[0].clientY;
                    }
                });

                window.addEventListener('touchend', () => {
                    this.mouse.x = -999;
                    this.mouse.y = -999;
                });
            }
        }

        let hasNavigated = false;

        // Apple-style scroll animation
        function handleScroll() {
            if (hasNavigated) return;

            const scrollTop = window.pageYOffset;
            const windowHeight = window.innerHeight;
            const launchSection = document.querySelector('.launch-section');
            const launchText = document.getElementById('launchText');
            const previewContainer = document.getElementById('previewContainer');
            
            if (!launchSection) return;

            const sectionTop = launchSection.offsetTop;
            const sectionHeight = launchSection.offsetHeight;
            const progress = Math.max(0, Math.min(1, (scrollTop - sectionTop) / (sectionHeight - windowHeight)));

            if (progress > 0.1) {
                launchText.classList.add('visible');
            }

            if (progress > 0.3) {
                const scaleProgress = Math.min(1, (progress - 0.3) / 0.4);
                const scale = 1 + (scaleProgress * 2);
                const brightness = 1 + (scaleProgress * 0.3);
                
                previewContainer.style.transform = `scale(${scale})`;
                previewContainer.style.filter = `brightness(${brightness})`;
                previewContainer.style.boxShadow = `0 ${20 + scaleProgress * 40}px ${60 + scaleProgress * 100}px rgba(59, 130, 246, ${0.3 + scaleProgress * 0.4})`;

                if (scaleProgress > 0.85 && !hasNavigated) {
                    hasNavigated = true;
                    triggerTransition();
                }
            }
        }

        function triggerTransition() {
            const overlay = document.getElementById('transitionOverlay');
            const transitionPreview = document.getElementById('transitionPreview');
            
            // Show overlay
            overlay.classList.add('active');
            
            // Expand the preview to fullscreen
            setTimeout(() => {
                transitionPreview.classList.add('expand');
            }, 100);
            
            // Navigate after animation completes
            setTimeout(() => {
                window.location.href = './Location_page.html';
            }, 1500);
        }

        document.addEventListener('DOMContentLoaded', function() {
            // Initialize reactive background
            new ReactiveBackground();
            
            // Add hover effects to link cards
            const linkCards = document.querySelectorAll('.link-card');
            linkCards.forEach(card => {
                card.addEventListener('mouseenter', function() {
                    if (!this.querySelector('.link-button[style*="cursor: default"]')) {
                        this.style.transform = 'translateY(-8px) scale(1.02)';
                    }
                });
                card.addEventListener('mouseleave', function() {
                    if (!this.querySelector('.link-button[style*="cursor: default"]')) {
                        this.style.transform = 'translateY(0) scale(1)';
                    }
                });
            });

            // Click handler for preview container
            document.getElementById('previewContainer').addEventListener('click', () => {
                if (!hasNavigated) {
                    hasNavigated = true;
                    triggerTransition();
                }
            });

            window.addEventListener('scroll', handleScroll);
        });

        // Parallax effect for hero section
        window.addEventListener('scroll', function() {
            const scrolled = window.pageYOffset;
            const hero = document.querySelector('.hero');
            const rate = scrolled * -0.5;
            hero.style.transform = `translateY(${rate}px)`;
        });
    </script>
</body>
</html>